#+title: "Common Lisp"
#+date: 2020-12-14T10:57:31+08:00
#+draft: false

** 安装

sudo pacman -S sbcl

** 将文件内函数发送到Lisp进行求值并编译

在DEFUN定义内部的任意位置或者刚好在其后面时，输入C-c C-c, 这将启动slime-compile-defun命令.

然后C-c C-z或者C-x b切换到repl进行调用。

如果出错将启动调试器，输入q退出调试器。

如果一个文件中有大量的定义时，加载整个文件更加便利：
+ (load "hello.lisp")
+ 或者先编译后加载：（load (compile "hello.lisp")）
+ 不使用REPL,在源文件中加载：C-c C-l调用命令slime-load-file加载文件；
  + 或者C-c C-k 编译并加载当前缓冲区所关联的文件

** 全局变量：defvar 和 星号 

(defvar **db** nil)
push宏添加项： (defun add-record (cd) (push cd **db**))

** 关键字形参

(defun foo (&key a b c ))
(foo :c 1 :a 2 b:66)

默认值
(defun foo (&key a (b 20) (c 30 c-p)))
(foo) => (NIL 20 30 NIL) ;;其中c-p表示c变量是否是传入，还是使用的默认值

** 常量名：以+开始和结尾

** 原子

原子可以被分为两个类别：符号和所有其他内容。
符号就是变量名。所有其他内容包括数字和字符串，都是自求值对象。

符号也可能是自求值--它们所命名的变量可以被赋值成符号本身的值，比如常量T和NIL，即所谓的真值和假值。
另一类自求值是*关键字*符号--以名字冒号开始的符号。会自动定义个以此命名的常值变量并以该符号作为其值。

** 函数

** 特殊表达式

** 宏

一个以S-表达式为其参数的函数，并返回一个LISP形式，然后对其求值并用该值取代宏形式。
求值分为两个阶段：
1. 宏形式的元素不经求值即被传递到宏函数中；
2. 由宏函数返回的形式（展开式）按照正常的求值规则进行求值。
COMPILE-FILE编译时展开，LOAD加载时进行执行求值。

** 真，假和等价

符号NIL是唯一的假值；其他都是真值。
符号T是标准的真值。
NIL是唯一一个即是原子又是列表的对象。可用来表示空列表。

等价：
+ =用来比较数字；
+ CHAR=比较字符串，以此类推；

四个通用等价谓词：
+ EQ：测试对象标识；不要用于比较数字和字符串；
+ EQL：类似EQ，可用来比较数字和字符串；
+ EQUAL：如果两个对象值或者结构内容都相同，则视为等价；
+ EQUALP：同EQUAL，更宽松，忽略大小写。1,1.0是等价的。

** 5. 函数 

定义：
#+BEGIN_SRC LISP
(defun name (parameter*)
  "OPTION documentation string."
  body-form*)
#+END_SRC

*** 可选形参

在必要形参的名字之后放置符号&optional，这个符号后面的都属于可选的形参。

**** 默认值

+ 简单的提供一个值：(defun foo (a &optional (b *10*)) (list a b))
+ 通过其他参数来赋值：(defun foo (a &option (b *a*)) (list a b))

***** 判断是否使用了默认值

在默认值表达式之后添加一个变量名，如果使用了默认值，则此变量值为T，否则为NIL；
此变量名命名规则：真实形参名-supplied-p
(defun foo (a b &optional (c 3 c-supplied-p)) (list a b c c-supplied-p))

*** 剩余形参(可变数量的参数)

(defun format (stream string &rest values) ...)
(defun + (&rest numbers) ... )
符号&rest。

*** 关键字形参

在&optional和&rest形参之后，可以加上符号&key以及任意数量的关键字形参标识符。
(defun foo (x y &key a b c) (list a b c))
(foo 1 2 :c 3) => (1 2 NIL NIL 3)
当调用时，如果一个给定的关键字没有出现在实参列表中，则对应的形参被赋予默认值(没有则为NIL)，类似可选形参那样。

也可以提供默认值：(defun foo (x y (&key (a 10) (b 0 b-supplied-p) (c (+ a b))) (list a b c b-supplied-p))

指定关键字不同于实际形参名字：需要将&key之后的形参名替换为一个列表：
(defun foo (x y &key ((:apple a)) ((:box b) 0) ((:car c) 0 c-supplied-p))
   (list a b c c-supplied-p))

*** 混合不同的形参

顺序：必要形参，可选形参，剩余形参，关键字形参。

*** 函数返回值

默认最后一个表达式的值被当做整个函数的返回值。
但某些时候，可以直接使用RETURN-FROM特殊操作符，直接返回。
(defun foo (n) (dotimes (i 10) (dotimes (j 10) (when (> (* i j) n) ( return-from foo (list i j))))))

*** 高阶函数：函数作为返回或参数

特殊操作符FUNCTION：用来获取一个函数对象的方法；参数为函数名。
对应语法糖：#'
(function foo) => #<Interpreted Function FOO>
等价: #'foo

函数对象可通过两个函数来进行调用：
+ FUNCALL: (foo 1 2) => (funcall #'foo 1 2)
+ APPLY: (apply #'foo '(1 2))
apply第二个参数是一个列表，而非单独的实参。

*** 匿名函数LAMBDA

(lambda (parameters) body)

(lambda (x) (* 2 x))

用途：
+ 强调将LAMBDA表达式用在任何一个正常函数名可以出现的场合都是合法的；
+ 制作闭包，即捕捉了其创建时环境信息的函数。


** 6. 变量

支持两种变量：
+ 词法lexical变量 == 局部变量；
+ 动态dynamic变量 == 全局变量；

引入新变量：LET特殊操作符：
(let (variable*)
  body-form*)

其中body-form表达式的值，作为LET表达式的返回。
(let ((x 10) (y 11) z) ...) => x:10 y:11 z:NIL

还有种绑定方式LET*, 区别在于LET中的变量只能用在body-form中，而LET*中，变量可以用在后面引入的变量中。
(let* ((x 10) (y *(+ x 10)*)) ... )

*** 词法变量和闭包

*** 动态变量（全局变量）

DEFVAR和DEFPARAMETER:
都接受：一个变量名，初始值和可选的文档字符串。
全局变量命名习惯以*开始和结尾的名字。

区别：
+ DEFPARAMETER总是将初始值赋给变量，而DEFVAR只有当变量未定义时才这样做；
+ DEFVAR也可以不带初始值来使用，这样的变量是未绑定的(unbound)；

应该使用DEFVAR。

*** 常量

所有常量都是全局的。
DEFCONSTANT定义，类似DEFVAR。
命名约定：以+开始和结尾。

*** 赋值

一旦完成了绑定，则可以获取值或者设置新值。
赋值操作符：SETF
(setf /place/ /value/)
因为setf是 *宏* ，所以它会检查它所赋值的place的形式，并展开成适当的底层操作来修改那个位置(place)；

如果place为变量，则会调用SETQ。
(setf x 1 y 3) 同时赋值x,y。
(setf x (setf y 3)) 同时赋值x,y为相同值。

如果place为其他数据结构比如数组，哈希表，或者用户自定义对象中的字段：
Array :(setf (aref a o) 10)
Hash table:( setf (gethash 'key hash) 10)
slot named 'field' : (setf ( field o) 10)

*** 其他修改位置的方式

自增、自减：
(setf x (+ x 1)) => (incf x)
(setf x (- x 1)) => (decf x)
(setf x (+ x 10)) => (incf x 10)

类似INCF和DECF这种宏为修改宏。

ROTATEF:交互变量的值：(rotatef a b c d) 循环向左移动：a=b b=c c=d d=a
SHIFTF: 将值向左移动，最后一个参数的值移动到倒数第二个参数上，其他的依次向左移动，第一个参数最初值被简单的返回。

** 宏：标准控制构造

每个宏定义了自己的语法，能够决定那些被传递的S-表达式如何转换成LISP形式。

*** WHEN和UNLESS

PROGN操作符可以按照顺序执行任意数量的形式，并返回最后一个形式的值。

(defmacro when (condition &rest body)
  `(if ,condition (progn ,@body)))

(defmacro unless (condition &rest body)
  `(if (not ,condition) (progn ,@body)))

*** COND

(cond 
  (test-1 form*)
     .
     .
     .
  (test-N form*))

*** AND,OR和NOT

*** 循环

DO，DOLIST（列表上循环），DOTIMES（计数器上循环），LOOP

**** DOLIST

(dolist (var list-form)
  body-form*)

(dolist (x '(1 2 3)) (print x))

dolist本身求值为NIL。意思是这个表达式返回NIL。
如果要在中途结束，则需要使用return。
(dolist (x '(1 2 3)) (print x) (if (evenp x) (return)))

**** DOTIMES

(dotimes (var count-form)
  body-form*)

其中count-form必须能求值是一个整数，var则从0开始到count-1结束。

**** DO

(do (variable-definition*)
    (end-test-form result-form*)
  statement*)

其中variable-definition表达式的完整形式为含有三个元素的列表：
(var init-form step-form)
第一次赋值为init-form，以后每次通过step-form计算。
init-form可选，如果没有，则var为NIL。
step-form可选，此时var每次循环不会变化，除非再循环体中被赋值。

迭代开始时，end-test-form会被求值，如果为NIL则循环继续，依次求值statement*。

当end-test-form为真时，result-form会被求值，且最后一个结果作为DO表达式的返回。


(do ((i 0 (+ i 1)))
  (( >= i 4))
  (print i))

**** LOOP

简单的情形使用DOLIST和DOTIMES，如果不符合需要就需要使用DO，不然就需要使用LOOP。

两种类型的LOOP：简化和扩展。

简化：
(loop body-form*) 无限循环，除非return。

扩展：
符号across，and,below,collecting,counting,finally,for,from,summing,then,to等都是循环关键字。

** 如何自定义宏

*** 宏展开期和运行期

当编写宏时，你是在编写生成代码的代码。

